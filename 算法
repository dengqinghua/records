24点计算
问题描述

列表项
输入： a3, a2, a1, a0
输出： 若能得到运算结果为24，则输出一个对应的运算表达式。

要求：
1. 仅采用 加减乘除 四则运算
2. 可以使用括号
3. 每个数字只能使用一次
4. 选出一组解即可

eg:

输入： 11, 8, 3, 5
输出： (11 - 8) * (3 + 5) = 24

分析与解法
解法一： 穷举法

遍历次数分析
不考虑括号, 需要对4个数字进行全排列，总共有 4! = 4 X 3 X 2 X 1 = 24种排列。4个数字总共需要3个运算符，共有 4 * 4 * 4 种表达式。因此在不考虑括号的情形下，总数为

4! * (4 * 4 * 4) = 7680

考虑括号，对于4个数字，共有5种加括号的方式：

(A(B(CD)))、(A((BC)D))、((AB)(CD))、((A(BC))D)、(((AB)C)D)

  总共需要便遍历的表达式最多有

  4! * (4 * 4 * 4) * 5 = 7680

  解题思路

  设4个数组成的集合为 A = {1, 2, 3, 4}, 定义f(A) 为对集合A做四则运算得到所有的值的集合

  首先从集合A 中任意取两个数, 如1，2, 另A = A - {1, 2}, 对取出来的值分别做四则运算，

  1 + 2 = 3
  1 * 2 = 2
  1 - 2 = -1
  1 / 2 = 0.5

  将得到的结果 加入到几个A, 可以得到集合B，C，D，E

  B = { 3, 3, 4 }
  C = { 2, 3, 4 }
  D = { -1, 3, 4 }
  E = { 0.5, 3, 4 }

  从而问题规模从4个数降到了3个数，成了3个数的自问题之和.

f(A) = f(B) U f(C) U f(D) U f(E)

  可以得到递归算法如下：

# 初始输入值nums = [1, 2, 3, 4]
def calculate(nums)
  if nums.size == 2
  (最后的结果是否是24) ? 输出表达式 : 无解
  end
loop(从数组里任意取出两个数的组合)
  [+, - , *, /].each do |运算符|
  1. 计算在该组合下的计算结果
  2. 将该组合中的两个数从原数组里移除，
  并将步骤1的结果放入数组
  3. 对新数组调用calculate,
  如果找到一个表达式则返回
  4. 将步骤1的计算结果移除，
  并将组合中的两个数字重新放回数组中相应的位置
  end
  end
  end

  eg:

  calculate(1,2,3,4) => calculate(1*2, 3, 4) => "无解"
  => calculate(1,2,3,4) => calculate(1+2, 3, 4) => ... =>
  => calculate(1+2+3, 4) => calculate((1+2+3) * 4) => result: (1+2+3) * 4

  总结

  算法思路清晰，但是是一种穷举算法, 存在大量的冗余，例如没有考虑到加法和乘法的交换率等;

  可以对穷举法进行简单的改进，如设置如果 A > B, 则只进行A + B 的计算，遇到 B + A 则简单返回

  解法二. 分治法

  算法思路

  设4个数组成的集合为 A = {1, 2, 3, 4}, 定义f(A) 为对集合A做四则运算得到所有的值的集合

  将A划分为两个子集 A1 和 A - A1, 规定 A1 和 A - A1 均非空集 即：

A = A1 U (A-A1)

  分别对A1和(A - A1)中的元素进行四则运算, 可得到f(A1)和f(A - A1), 显然，有

f(A) = f(A1) U f(A - A1)

  给定两个多重集合A，B； 如A = {1, 2}, B = {3, 4}, 定义两个集合的元素运算为

  fork(A, B) = U { a+b, a-b, a*b, a/b(b!=0), b/a(a!=0)}

  其中

  (a, b) << A X B; a.is_a(A), b.is_a(B)

  eg:

  fork({1, 2}, {3, 4}) =
  U {
    1+3, 1-3, 3-1, 1*3, 1/3, 3/1,
    2+3, 2-3, 3-2, 2*3, 2/3, 3/2,
    1+4, 1-4, 4-1, 1*4, 1/4, 4/1,
    4+3, 4-3, 3-4, 4*3, 4/3, 3/4,
  }

设集合A有n个元素, B有m个元素, 那么fork的结果将有 n * m * 6 个元素

对于多重集合A，如果A至少有两个元素，则

f(A) = U(fork(f(A1), f(A - A1))

    其中A1取遍了A的非空子集。故可以得到算法思路如下

    f{1,2,3,4}
    / | \
    f{1}, f{2,3,4}) f{2}, f{1,3,4} .. f{1,2}, f{3,4}
/ |
f{2}, f{3,4} .. .. ..f{1}, f{3, 4} ..

上图为树形结构，数的每一个节点都是一个集合，每两个集合之间要进行fork()计算

最后，根节点 f{1,2,3,4} 将保存f(A)的结果

冗余分析
在上图中，可以看到重复的计算 f{3,4}, 针对冗余部分，可以将已经求解过的子问题放在一张表内，再次求解子问题的时候，可以访问该表，查询该子问题的解。

代码实现

f(i)的数目：

(2 ** 4 - 1)

  实际实现时候, 用二进制的方式表示集合和子集的概念

  a3, a2, a1, a0
  1 1 1 1
  f(2) = f(0010) = f{a1}
  f(7) = f(0111) = f{a2, a1, a0}
  f(15) = f(1111) = {a3, a3, a1, a0}

  将最后的结果放在一个数组内。

  F_NUM = 2 ** 4 - 1
  CARD_NUM = 4
def calculate(nums)
  @f_result = []
# @f_result[1] = a0
# @f_result[2] = a1
# @f_result[4] = a2
# @f_result[8] = a3
  (0...CARD_NUM).each do |num|
  @f_result[2 ** num] = nums[num]
  end
  (1..F_NUM).each do |num|
@f_result[i] = f(i)
  end
if f(F_NUM).keys.include?(24)
  f_result[F_NUM]
  else
  "无解"
  end
  end
def f(i)
  if @f_result[i].present?
  return @f_result[i]
  end
# 只有小于i的num才有可能成为i的真子集
# f(num) 为 f(i) 的一个真子集，则
# f(i-num) 为 f(i)的另一个真子集
#
# f(7) = f(0111) = f{a2, a1, a0}
# f(6) = f(0110) = f{a2, a1}
# ...
# f(1) = f(0001) = f{a0}
#
# (1..3).to_a = [1,2,3]
  (1..i-1).each do |num|
@f_result[num] << fork(f(i), f(i-num))
  end
  end
